function R = nds(P)
% Non-domination sorting. Duplicate solutions (same rows in P) are ignored
% for the dominance count and are assigned all the same rank.
%
% Inputs:
% - P : N-by-D matrix, where N is the number of points and D is the
%       number of elements (objectives) of each point.
%
% Outputs:
% - R : N-by-3 matrix. First column has the number of solutions by which
%       each solution is weakly dominated. Second column has the sub-front
%       where each solution belongs. Third column has the crowding
%       distance, i.e., the average Euclidean distance between each
%       solution and the solutions belonging to the same sub-front.
%
% Reference: K Deb, A Pratap, S Agarwal, T Meyarivan,
% "A fast and elitist multiobjective genetic algorithm: NSGA-II",
% IEEE Transactions on Evolutionary Computation, 2002.
%
% Example:
%
% P = [0.6850    0.2048
%     0.2649    0.2967
%     0.3348    0.6344
%     0.3037    0.4429
%     0.3659    0.0754
%     0.0220    0.5690
%     0.5135    0.3447
%     0.1898    0.4758]
%
% nds(P)
%      0     0     2.2361
%      3     2     0.0000
%      0     0     2.0000
%      1     1     2.2361
%      2     1     2.0000
%      1     1     1.7321
%      0     0     1.7321
%      1     1     1.7321
%
% You can then sort R and use the indices to sort P.
% [Rs, idx] = sortrows(R);
% Ps = P(idx,:);
% 
% Here is an analysis of how [Rs, Ps] looks like:
%
%              Rs                    Ps
%     #dom  subf  avg dist |    Obj1      Obj2
%     -----------------------------------------
%     0     0     6.7823   |   0.5135    0.3447
%     0     0     7.8740   |   0.3348    0.6344  <- Pareto-front solutions
%     0     0     8.6023   |   0.6850    0.2048
%     -----------------------------------------
%     1     1     11.1355  |   0.0220    0.5690
%     1     1     12.0830  |   0.1898    0.4758  <- First subfront
%     1     1     13.3417  |   0.3037    0.4429
%     2     1     12.8062  |   0.3659    0.0754
%     -----------------------------------------
%     3     2     0.0000   |   0.2649    0.2967  <- Second subfront

tmp = P;
uniqueP = unique(P,'rows');
[n, d] = size(P);
rank = zeros(n,1);
avgdist = zeros(n,1);
j = 0;

% Extract all the sub-fronts and rank each solution. First, Pareto-front 
% solutions are identified, given rank 0 and deleted. Then, iteratively, 
% sub-fronts are identified and their rank is progressively increased.
while ~isempty(tmp)
    
    subfront = pareto(tmp);
    
    % Indices (because of possible duplicates)
    idx_P = ismember(P, subfront, 'rows');
    idx_tmp = ismember(tmp, subfront, 'rows');
    
    % Assign the rank
    rank(idx_P) = j;
    tmp(idx_tmp,:) = [];
    j = j + 1;
    
    % Assign the crowding distance
    subfront = P(idx_P,:); % Include duplicates for correct indexing
    C = mat2cell(subfront,ones(size(subfront,1),1),d);
    norms = cellfun( ...
        @(X)mean( find( sqrt( sum( abs(bsxfun(@plus, X, -subfront)).^2,2) ) ) ), ...
        C, 'UniformOutput', false );
    subdist = sqrt(sum(abs(bb).^2,2))
    % With 'find' we ignore 0 distances, i.e. distances between duplicates
    avgdist(idx_P) = vertcat(subdist{:});
    
end

% Count the number of solutions by which every solution is weakly dominated
C = mat2cell(P,ones(n,1),d);
dominance = cellfun( ...
    @(X) sum( sum( bsxfun(@ge, uniqueP, X), 2) == d ), ...
    C, 'UniformOutput', false);
ndominate = vertcat(dominance{:}) - 1;

R = [ndominate, rank, avgdist];

end